function [U mniter] = TDHdiag_tsn2(H0, Vt, ui, T, Nts, Nt_ts, tol)
% The program solves Schrodinger equation for a time dependent Hamiltonian.
% H0 is the time-independent Hamiltonian matrix.
% Vt is the time-dependent disturbance. It is a 4D tensor; the first 2 indices represent the indices
% of the matrix in a particular time point. The 3'rd index represents the
% time step. The 4'th represents the Chebychev time points within the time
% step, of the Nt_ts order Chebychev polynom.
% ui is the initial state vector.
% T is the total time. Nts is the number of time steps. Nt_ts is the number
% of Chebychev points within the time step.
% tol is the desired tolerance of the convergence.
% The program is based the "Chebychev propagator with iterative time ordering"
% procedure. The matrices of functions are caculated using a
% diagonalization method.
    Tts = T/Nts;
    tmidi = round(Nt_ts/2);
    dim = length(ui);
    U = zeros(dim, Nts + 1);
    U(:, 1) = ui;
    tcheb = -cos(((1:Nt_ts) - 1)*pi/(Nt_ts-1));
    t_ts = 0.5*(tcheb+1)*Tts;
%    t_2ts = [t_ts.'; Tts + t_ts(2:Nt_ts).'].';
%     Nt_2ts = 2*Nt_ts - 1;
%    Cc2t = cheb2taylor(Nt_ts-1);
%    Cr2t = r2Taylor(t_ts);
    Cr2t = r2Taylor4(t_ts, Tts);
%    U0 = zeros(dim, Nt_ts+1);
    Unew = zeros(dim, Nt_ts);
    Fi = zeros(dim, Nt_ts);
    Lambda = zeros(dim, Nt_ts+1);
    Vtts = zeros(dim, dim, Nt_ts);
%    Ctaylor = zeros(dim, Nt_ts);
    Uguess = guess_ts1(H0, ui, dim, t_ts, Nt_ts);
    allniter = 0;
    Niter = 1000;
    for tsi = 1:Nts
        Ulast = Uguess;
        Vhalf = Vt(:, :, tsi, tmidi);
        for ti = 1:Nt_ts
            Vtts(:, :, ti) = Vt(:, :, tsi, ti) - Vhalf;
        end
        Ht = H0 + Vhalf;
        [P, D] = eig(Ht);
        eigval = diag(D);
        Lambda(:, 1) = P\U(:, tsi);
%        Ulast = U0; 
        niter = 0;
        reldif = tol + 1;
        while (reldif>tol && niter<Niter)
            % Calculation of the inhomogeneous fi vectors:
            for ti = 1:Nt_ts
                Fi(:, ti) = -1i*P\(Vtts(:, :, ti)*Ulast(:, ti));
            end
            % Calculation of the coefficients of the form of Taylor
            % expansion, from the coefficients of the Newton
            % interpolation in the points t_ts:
%            Cnewton = devdif(t_ts, Fi);
            Cnewton = devdif(t_ts*4/Tts, Fi);
%            Ctaylor = Newton2Taylor(t_ts, Cnewton);            
            Ctaylor = zeros(dim, Nt_ts);
            Ctaylor(:, 1) = Cnewton(:, 1);
            for Newtoni = 2:Nt_ts
                for Taylori = 1:Newtoni
                    Ctaylor(:, Taylori) = Ctaylor(:, Taylori) + Cnewton(:, Newtoni)*Cr2t(Newtoni, Taylori);
                end
            end
            % Calculation of the Lambda vectors:
            for polyi = 2:(Nt_ts+1)
%                Lambda(:, polyi) = -1i*eigval.*Lambda(:, polyi-1) + Ctaylor(:, polyi-1);
                Lambda(:, polyi) = (-1i*eigval.*Lambda(:, polyi-1) + Ctaylor(:, polyi-1))/(polyi - 1);
            end
            % Calculation of the wave function in all the time points
            % within the time step:
            Unew = P*UfromLamb(Lambda, eigval, dim, t_ts, Nt_ts);
            reldif = norm(Unew(:, Nt_ts) - Ulast(:, Nt_ts))/norm(Ulast(:, Nt_ts));
            Ulast = Unew;
            niter = niter + 1;
        end
        if niter == Niter
            fprintf('The program has failed to achieve the desired tolerance.\n')
        end
        allniter = allniter + niter;
        %niter
        U(:, tsi+1) = Unew(:, Nt_ts);
        % The new guess is an extrapolation from the points within the
        % previous time step:
        Uguess(:, 1) = Unew(:, Nt_ts);
        Uguess(:, 2:Nt_ts) = P*UfromLamb(Lambda, eigval, dim, Tts + t_ts(2:Nt_ts), Nt_ts-1);
        if ~isfinite(U(1, tsi + 1))
            display('Error.');
            return
        end
    end
    mniter = allniter/Nts;
end

function F = makeF(eigval, dim, t, Nt, Nt_ts) 
    F = zeros(dim, Nt);
    expeigval = exp(-1i*eigval*t);
    tsmall = t(min(abs(eigval.'))*t<Nt_ts+1);
    Ntsmall = length(tsmall);
    tlarge = t(min(abs(eigval.'))*t>=Nt_ts+1);
    Ntlarge = Nt - Ntsmall;
    Mtaylor = -1i*eigval*tsmall;
    for ti = 1:Ntsmall
        Mterm = ones(dim, 1);
%        lastMterm = Mterm;
        F(:, ti) = Mterm;
        polydeg = 1;
%        while norm(Mterm)/norm(F(:, ti)) > eps
        while norm(Mterm)/norm(F(:, ti)) > eps
%        while norm(Mterm)/norm(lastMterm) > 1e-3
%            lastMterm = Mterm;
            Mterm = Mtaylor(:, ti).*Mterm/(polydeg + Nt_ts);
            F(:, ti) = F(:, ti) + Mterm;
            polydeg = polydeg + 1;
        end
    end
    F(:, (Ntsmall + 1):Nt) = expeigval(:, (Ntsmall + 1):Nt);
    Mezer = -1i*eigval*tlarge;
    for polyi = 1:Nt_ts
        F(:, (Ntsmall + 1):Nt) = polyi*(F(:, (Ntsmall + 1):Nt) - ones(dim, Ntlarge))./Mezer;
    end
    F = F.*(ones(dim, 1)*(t.^Nt_ts));
end

function Uguess = guess_ts1(H0, ui, dim, t_ts, Nt_ts)
    Uguess = zeros(dim, Nt_ts);
    [P, D] = eig(H0);
    eigval = diag(D);
    expeigval = exp(-1i*eigval*t_ts);
    uiDbase = P\ui;
    for ti = 1:Nt_ts
        Uguess(:, ti) = expeigval(:, ti).*uiDbase;
    end
    Uguess = P*Uguess;
end

function U = UfromLamb(Lambda, eigval, dim, t, Nt)
    U = zeros(dim, Nt);
    Nt_ts = size(Lambda, 2) - 1;
    F = makeF(eigval, dim, t, Nt, Nt_ts);
    for ti = 1:Nt
        U(:, ti) = F(:, ti).*Lambda(:, Nt+1);
    end
    for polydeg = 0:(Nt-1)
        U = U + Lambda(:, polydeg+1)*t.^polydeg;
    end
end