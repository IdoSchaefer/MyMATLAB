function [fieldt, fieldw, psi, evat, evaw, evmut, evmuw, relE, conv, niter, mallniterc, Jterms, maxgrad, alpha, invHess] = OCfx_qn2(psi0,...
    Vf, m, xdomain, mu_x, a0, penalnormf, Dpenalnormf, fguess, filterE, filtera, options, T, dt, Nt_ts, Nkr, tolprop)
% The function solves an OCT procedure for the optimization of HHG in one dimension, or
% other HG problems defined on a one-dimensional spatial grid. A
% quasi-Newton optimization procedure is applied.
%%% Input: %%%
% psi0: The initial state vector
% Vf: The stationary potential; a functon handle of the form @(x), where
% the input is the x grid. Alternatively, Vf can be a column vector of the
% potential values in x.
% m: The mass (in HHG, the electron mass, which is 1 in atomic units)
% xdomain: The boundaries of the x domain, where xdomain = [min_x, max_x]
% mu_x: The dipole function mu evaluated at the x grid points; a column 
% vector of the dimension of the x grid; mu_x is used in the Hamiltonian for the
% interaction term with the external field, -field(t)*mu_x. In HHG, insert 
% here the numerical x vector which its derivative decays to 0 near the 
% absorbing boundaries.
% a0: the stationary acceleration, evaluated at the x grid points; a
% column vector of the dimension of the x grid 
% penalnormf: The penalty function on the ionization; a function handle of
% the form @(sq_norm_psi), where the input is <psi(T)|psi(T)>
% Dpenalnormf: The derivative of the function represented by penalnormf; a
% function handle of the form @(sq_norm_psi), where the input is <psi(T)|psi(T)>
% fguess: The guess field function in the frequency domain; a function
% handle of the form @(w), where w is a column vector which represents the
% omega grid. Aternatively, fguess can be a column vector of the guess
% function evaluated at the omega grid points. If the guess does not
% satisfy the 0 boundary conditions of the temporal profile, the program
% constructs a constrained field with the 0 boundary conditions from the
% unconstrained field.
% filterE: The scaled filter function of the driving electric field spectrum; a
% function handle of the form @(w), where w is a column vector which
% represents the omega grid
% filtera: The filter function of the emission spectrum, represented by the
% stationary acceleration expectation spectrum; a function handle of the
% form @(w), where w is a column vector which represents the omega grid
% options: The options structure of the BFGS search procedure (see
% quasiNewton.m and default_op_qn.m); if is empty (substituted with []), the default is set by
% the procedure optionsOCqn.m, using the tol and maxNiter input parameters.
% T: The final time
% dt: The time-step
% Nt_ts: The number of Chebyshev points in the internal grid in each
% time-step, using the semi-global propagator.
% Nkr: The dimension of the Krylov approximation in the semi-global propagator
% tolprop: The tolerance parameter of the semi-global propagator
%%% Output: %%%
% fieldt: The optimized time-dependent electric field, evaluated at the
% points of the main time-grid, t = 0:dt:T (not at the intermediate 
% Chebyshev point structure of the semi-global propagation); a row vector
% fieldw: The optimized electric field in the omega domain; a row vector
% psi: The state in all time-points of the process under the influence of the optimized
% field; evaluated at the main time-grid, where the different time-points
% are represented by separate columns.
% evat: The time-dependent expectation value of the stationary
% acceleration, evaluated at the main time-grid; a row vector
% evaw: evat in the omega domain; a row vector
% evmut: The time-dependent expectation value of the dipole, defined by
% mu_x; a row vector
% evmuw: evmut in the omega domain; a row vector
% relE: The relative difference of the field from the previous iteration at the
% end of the optimization process
% conv: The convergence history, i.e. J as a function of the iteration number;
% a row vector of dimension niter+1, where the 1'st entry represents the
% guess field
% niter: The total number of iterations
% mallniterc: The mean number of semi-global iterations in the whole
% optimization process; should be close to 1 for efficiency.
% Jterms: A structure which contains the values of the different components
% of J. It has the fields: Jmax, Jenergy, Jion.
% maxgrad: The infinity norm of the gradient at the end of the optimization
% process
% alpha: The alpha parameter at the end of the optimization process (see
% quasiNewton.m)
% invHess: The inverse Hessian at the end of the optimization process

    % The number of time-points:
    Nt = T/dt;
    % The distance between adjacent points in the omega grid:
    dw = pi/T;
    % Integration weights of the boundary including omega grid:
    integw = [dw/2; ones(Nt - 1, 1)*dw; dw/2];
    % Additional factor for conversions between the time and frequency grid
    % by the DCT transformation:
    dctfactor = T/(sqrt(Nt*pi));
    % The dimension of the problem, whcih is the number of x grid points:
    Nx = length(psi0);
    % The index of the last point in the semi-global time-grid, where the
    % internal Chebyshev points are also counted:
    allt_lasti = Nt*(Nt_ts - 1) + 1;
    % The index of the last point in the semi-global time-grid, including
    % the test-point for error computation:
    allt_tp_lasti = Nt*Nt_ts + 1;
    indices_excluding_tp = 1:allt_tp_lasti;
    indices_excluding_tp(Nt_ts:Nt_ts:Nt*Nt_ts) = [];
%     is_not_testp = true(1, allt_tp_lasti);
%     % The entries of the propagation grid, without the test points, are
%     % true:
%     is_not_testp(Nt_ts:Nt_ts:Nt*Nt_ts) = false;
    % The indices rearranged for the backward propagation:
    backwardi = allt_tp_lasti:-1:1;
    [backwardi(Nt_ts:Nt_ts:Nt*Nt_ts), backwardi(2:Nt_ts:((Nt - 1)*Nt_ts + 2))] =...
        deal(backwardi(2:Nt_ts:((Nt - 1)*Nt_ts + 2)), backwardi(Nt_ts:Nt_ts:Nt*Nt_ts));
    % Constructing the x grid:
    min_x = xdomain(1);
    max_x = xdomain(2);
    xdlength = max_x - min_x;
    dx = xdlength/Nx;
    x = (min_x:dx:(max_x - dx)).';
    % Constructing the p (momentum) grid:
    p = (0:(2*pi/xdlength):(2*pi*(1/dx - 1/xdlength))).';
    p((Nx/2 + 1):Nx) = p((Nx/2 + 1):Nx) - 2*pi/dx;
    % The kinetic energy in the p domain:
    K = p.^2/(2*m);
    % Defining the complex conjugate potential for the propagation of chi:
    if length(Vf) == 1
        % If Vf is a function handle:
        V0 = Vf(x);
    else
        % If Vf is a vector:
        V0 = Vf;
    end
    conjV0 = conj(V0);
    % The stationary acceleration diagonal matrix:
    a0M = spdiags(a0, 0, Nx, Nx);
    % The tolerance parameter of the propagation procedure:
    % The sum of the mean number of semi-global iterations of all 
    % propagations performed during the optimization process (required for
    % the computation of mallniterc):
    summniterc = 0;
    % The time-dependent field in the semi-global propagation grid (including the internal
    % Chebyshev points in each time-step):
    allfield = zeros(1, allt_tp_lasti);
    % The time-dependent stationary acceleration expectation value in the
    % semi-global propagation grid:
    allevat = zeros(allt_lasti, 1);
    % allevat filtered by the filtera function:
    evafil = zeros(allt_lasti, 1);
    % allevat in the omega domain:
    evaw = zeros(Nt + 1, 1);
    % The different terms in the functional J:
    Jmax = 0;
    Jenergy = 0;
    Jion = 0;
    % The term <chi(t)|mu|psi(t)> evaluated at the semi-global propagation
    % grid:
    chimupsi = zeros(allt_lasti, 1);
    % The reversed Chebyshev points in each time-step in the [-1, 1] domain:
    tcheb = -cos(((1:Nt_ts).' - 1)*pi/(Nt_ts-1));
    % The internal Chebyshev points of each time-step in the [0, dt] domain:
    t_ts = 0.5*(tcheb+1)*dt;
    % The test time-point for time-expansion error computation (see the SemiGlobal programs):
    test_tpoint = (t_ts(tmidi) + t_ts(tmidi + 1))/2;
    % The time-step internal structure including the test-point:
    t_ts_tp = [t_ts(1:(Nt_ts - 1)); test_tpoint];
    % The test-point for the backward propagation (coincides with the
    % test-point of the forward propagation, but is defined from the
    % opposite propagation direction):
    tp_backward = (t_ts(tmidi) + t_ts(tmidi - 1))/2;
    % The omega grid:
    w = (0:pi/T:pi/dt).';
    % The vector of the driving field filter-function, evaluated at w:
    vfilterE = filterE(w);
    % The indices of the w which participate in the optimization, where
    % the driving field spectrum does not attain negligible values (nz is
    % non-zero):
    iEnz = find(vfilterE>=eps*max(vfilterE));
%    [iEnz, ~, vfilterEnz] = find(vfilterE);
%    iEnz = find(vfilterE>=tolprop*max(vfilterE)/10);
    % vfilterE in the points which participate in the optimization:
    vfilterEnz = vfilterE(iEnz);
    % The integration weights of the internal grid Chebyshev points in the
    % semi-global prapagation time grid:
    igweights = chebweights(Nt_ts, 1).';
    igweights = [2*igweights(1); igweights(2:(Nt_ts - 1))];
    % The integration weights of the omega grid points which participate in
    % the optimization:
    integwnz = integw(iEnz);
    % The inverse cosine transform of the scaled filter function, evaluated
    % at t=0:
    dctfilterE0 = sqrt(2/pi)*sum(vfilterEnz.*integwnz);
    % Constructing a vector of cos(w*T) evaluated at all w values:
    coswT = ones(Nt + 1, 1);
    coswT(2:2:(Nt + 1)) = -1;
    % The inverse cosine transform of the scaled filter function, evaluated
    % at t=T:
    dctfilterET = sqrt(2/pi)*sum(vfilterEnz.*coswT(iEnz).*integwnz);
    % The determinant of the M matrix in the paper:
    deTdctfilterE  = dctfilterE0^2 - dctfilterET^2;
    % The driving field spectrum in all w:
    fieldw = zeros(Nt + 1, 1);
    if length(fguess) == 1
        % if fguess is a function handle:
        for wnzi = iEnz
            fieldw(wnzi) = fguess(w(wnzi));
        end
    else
        % if fguess is a vector:
        fieldw(iEnz) = fguess(iEnz);
    end
    % The driving field spectrum the omega values which participate in the
    % optimization:
    fieldwnz = fieldw(iEnz);
    % If the guess field doesn't satisfy the temporal boundary conditions, a new
    % guess field is constructed which satisfies the boundary conditions:
    if sqrt(2/pi)*abs(sum(fieldwnz.*integwnz)) > tolprop*1e-2 || sqrt(2/pi)*abs(sum(fieldwnz.*coswT(iEnz).*integwnz)) > tolprop*1e-2
        fieldwnz = getfieldwcon(fieldwnz);
    end
    % The filter function of the stationary acceleration expectation,
    % evaluated at the w grid points:
    vfiltera = filtera(w);
    % psi at the semi-global propagation grid:
    allpsi = zeros(Nx, allt_tp_lasti);
    % a*psi at the semi-global propagation grid, where a is the stationay
    % acceleration operator:
    allapsi = zeros(Nx, allt_tp_lasti);
    % The inhomogeneous term in the inhomogeneous Schreodinger equation for
    % the chi propagation:
    chiihterm = zeros(Nx, allt_lasti);
    % nprop counts the number of propagations:
    nprop = 0;
    if isempty(options)
        % Setting the default options:
        options = optionsOCqn(1e-4, 1e3);
    end
    if isempty(options.invHess0)
        % Initializing the approximated Hessian to the default: 
        options.invHess0 = diag(vfilterEnz./(2*integwnz));
    end
    if options.maxNiter > 0
        % Performing an optimization process of fieldwnz:
        [fieldwnz, ~, minusgrad, niter, ~, ~, dif_fieldw, minus_conv, alpha, invHess] = quasiNewton(@Jeval, fieldwnz, options);
    else
        % If options.maxNiter == 0, the program returns the output variables
        % for the input field:
        [minus_conv, minusgrad] = Jeval(fieldwnz);
        niter = 0;
        dif_fieldw = 0;
        alpha = [];
        invHess = options.invHess0;
    end
    % Preparing the output variables:
    fieldw = fieldw.';
    maxgrad = max(abs(minusgrad));
    conv = -minus_conv;
    relE = norm(dif_fieldw)/norm(fieldwnz);
    niter
    nprop
    psi = allpsi(:, 1:Nt_ts:allt_tp_lasti);
    fieldt = allfield(1:(Nt_ts - 1):allt_lasti);
    evat = allevat(1:(Nt_ts - 1):allt_lasti).';
    allevmut = real(evmiu(allpsi, mu_x));
    evmut = allevmut(1:(Nt_ts - 1):allt_lasti);
    evmuw = dctIfrom_ig_sym1(allevmut, T, t_ts(1:(Nt_ts - 1)).', igweights.')*dctfactor;
    mallniterc = summniterc/nprop;
    Jterms.Jmax = Jmax;
    Jterms.Jenergy = Jenergy;
    Jterms.Jion = Jion;
    beep
    
    %%% Nested functions: %%%
    
    function [minusJ, minusgrad] = Jeval(fieldwnz)
    % The optimization function
    % Input:
    % fieldwnz: The driving field spectrum at the omega points which
    % participate in the optimization
    % Output:
    % minusJ: The objective of the optimization, which is -J
    % minusgrad: The gradient of the optimization, which is minus the
    % gradient of J w.r.t. fieldwnz
        fieldw(iEnz) = fieldwnz;
        % Obtaining the the temporal driving field from its spectrum,
        % evaluated at the semi-global propagation grid:
        allfield = dctIintgrid1(fieldw.', T, t_ts_tp.')/dctfactor;
        % The forward propagation of psi:
        %[allpsi, ~, mniterc] = solveOCkr(@ihfieldmiux, K, Vf, x, psi0, [0 T], Nt, Nt_ts, Nkr, tolprop, allfield.', mu_x);
        [~, mniterc, ~, max_errors_psi, history_psi] = SemiGlobalHparams(@(psi, field, v) Hpsi(K, V0 - mu_x*field, v),...
            @(psi1, field1, psi2, field2) -mu_x*(field1 - field2).*psi1, 0, allfield, [], [], psi0, [0, T], Nt, Nt_ts, Nkr, tolprop,...
            10, 16, test_tpoint, false);
        allpsi(:, indices_excluding_tp) = history_psi.U;
        allpsi(:, Nt_ts:Nt_ts:Nt*Nt_ts) = history_psi.Utestp;
        summniterc = summniterc + mniterc;
        % Computing the stationary acceleration expectation at the semi-global
        % propagation grid, for the chi propagation:
        allapsi = a0M*allpsi;
        % The time-dependent part of the acceleration operator is omitted,
        % since it contributes low frequencies only. This just increases the
        % background of the signal, and does not contain any interesting
        % information.
        for allti = 1:allt_lasti
        % The values of the expectation value are supposed to be real:
            allevat(indices_excluding_tp(allti)) = real(allpsi(:, indices_excluding_tp(allti))'*allapsi(:, indices_excluding_tp(allti)));
        end
        % The spectrum of the stationary acceleration expectation is
        % computed utilizing the data in the whole propagation grid:
        evaw = dctIfrom_ig_sym1(allevat, T, t_ts(1:(Nt_ts - 1)), igweights)*dctfactor;
        % Obtaining chiihterm (the inhomogeneous term for the chi
        % propagation):
        get_chiihterm(allapsi);
        psiT = allpsi(:, allt_tp_lasti);
        % The square norm of psi at t=T, for the computation of J:
        sq_norm_psiT = psiT'*psiT;
        % The final condition for the chi backward propagation:
        chiT = Dpenalnormf(sq_norm_psiT)*psiT;
        % The backward propagation of chi:
%         [allchi, ~, mniterc] = solveOCkr(@ihalltchimiux, K, conjVf, x, chiT, [T 0], Nt, Nt_ts, Nkr, tolprop,...
%             allfield(allt_lasti:-1:1).', mu_x, chiihterm);
        [~, mniterc, ~, max_errors_chi, history_chi] = SemiGlobalHparams(@(chi, field, v) Hpsi(K, conjV0 - mu_x*field, v),...
            @(chi1, field1, chi2, field2) -mu_x*(field1 - field2).*chi1, 0, allfield(backwardi), chiihterm, [], chiT, [T, 0], Nt, Nt_ts, Nkr, tolprop,...
            10, 16, tp_backward, false);
        allchi = history_chi.U;
        % Note that allchi doesn't include the test-points, unlike allpsi.
        summniterc = summniterc + mniterc;
        nprop = nprop + 2;
        % Computing the objective -J:
        Jmax_fun = 0.5*evaw.^2.*vfiltera.*integw;
        Jmax = sum(Jmax_fun);
        Jenergy_fun = -(fieldwnz.^2./vfilterEnz).*integwnz;
        Jenergy = sum(Jenergy_fun);
        Jion = penalnormf(sq_norm_psiT);
        minusJ = -(Jmax + Jenergy + Jion);
        % Computing the -gradient.
        %  Obtaining <chi(t)|mu|psi(t)> at the propagation grid:
        for allti = 1:allt_lasti
            chimupsi(allti) = -imag(allchi(:, allt_lasti - allti + 1)'*(mu_x.*allpsi(:, indices_excluding_tp(allti))));
        end
        % Computing chimupsi transformed to the frequency domain,
        % utilizing the data in the entire propagation grid:
        dct_chimupsi = dctfactor*dctIfrom_ig_sym1(chimupsi, T, t_ts(1:(Nt_ts - 1)), igweights);
        % The unconstrained fieldw:
        newfieldw_unc_nz = dct_chimupsi(iEnz).*vfilterEnz;
        % Computing the Lagrange-multiplies of the temporal boundary
        % constraints from the unconstrained field:
        [lambda0, lambdaT] = fieldw_unc2lambda(newfieldw_unc_nz);
        minusgrad = 2*integwnz.*(fieldwnz./vfilterEnz - dct_chimupsi(iEnz) + lambda0 + lambdaT*coswT(iEnz));
    end

    function [lambda0, lambdaT] = fieldw_unc2lambda(fieldw_unc_nz)
    % The function computes the Lagrange-multiplies of the boundary
    % constraints, given an unconstrained field in the frequency domain,
    % evaluated at the omega values which participate in the optimization.
        % Computing the unconstrained field at t=0, by the DCT of the
        % driving field specrum evaluated at t=0:
        fieldt_unc0 = sqrt(2/pi)*sum(fieldw_unc_nz.*integwnz);
        % Computing the unconstrained field at t=T, by the DCT of the
        % driving field specrum evaluated at t=0:
        fieldt_uncT = sqrt(2/pi)*sum(fieldw_unc_nz.*coswT(iEnz).*integwnz);
        lambda0 = (fieldt_unc0*dctfilterE0 - fieldt_uncT*dctfilterET)/deTdctfilterE;
        lambdaT = (fieldt_uncT*dctfilterE0 - fieldt_unc0*dctfilterET)/deTdctfilterE;        
    end

    function fieldw_con = getfieldwcon(fieldw_unc_nz)
    % The function computes a constrained field spectrum, fieldw_con, with 0 boundaries in the
    % time domain, from the unconstrained field spectrum fieldw_unc.
        [lambda0, lambdaT] = fieldw_unc2lambda(fieldw_unc_nz);
        fieldw_con = fieldw_unc_nz - vfilterEnz.*(lambda0 + lambdaT*coswT(iEnz));
    end

    function get_chiihterm(allapsi)
    % The function computes the inhomogeneous term for the chi propagation
    % by the inhomogeneous Schreodinger equation.
        % The filtered evaw, transformed to the time grid and evaluated at
        % the semi-global propagation grid:
        evafil = dctIintgrid1(evaw.*vfiltera, T, t_ts_tp)/dctfactor;
        % The inhomogeneous term at the propagation grid:
        chiihterm = -allapsi(:, backwardi)*spdiags(evafil(backwardi), 0, allt_lasti, allt_lasti);     
    end

end